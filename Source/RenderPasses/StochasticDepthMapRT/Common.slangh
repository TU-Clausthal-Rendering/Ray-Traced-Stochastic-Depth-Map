Texture2D<float> depthInTex;

Texture2D<uint> rayMinTex; // contains float values: use asfloat()
Texture2D<uint> rayMaxTex; // contains float values: use asfloat()

StructuredBuffer<uint> stratifiedIndices;
StructuredBuffer<uint> stratifiedLookUpTable;

#define DEFAULT_DEPTH (NORMALIZE ? 1.0 : 3.40282347E+37F)

// Hash function from "Improved Alpha Testing Using Hashed Sampling"
float hash(float2 v)
{
    return frac(1.0e4 * sin(17.0 * v.x + 0.1 * v.y) * (0.1 + abs(sin(13.0 * v.y + v.x))));
}

// 3D hash function from "Improved Alpha Testing Using Hashed Sampling"
float hash3D(float3 v)
{
    return hash(float2(hash(v.xy), v.z));
}

// 4D hash function based on the 3D hash function
float hash4D(float4 v)
{
    return hash(float2(hash3D(v.xyz), v.w));
}

float RayToViewDepth(float3 rayDir, float rayT)
{
    float cosTheta = dot(normalize(gScene.camera.data.cameraW), rayDir);
    return rayT * cosTheta;
}

float ViewDepthToRay(float3 rayDir, float viewDepth)
{
    float cosTheta = dot(normalize(gScene.camera.data.cameraW), rayDir);
    return viewDepth / cosTheta;    
}

RayDesc initRayDesc(uint2 pixel, uint2 dim)
{
    RayDesc ray = gScene.camera.computeRayPinhole(pixel, dim).toRayDesc();
    float epsilon = 0.1 * gScene.camera.data.nearZ; // small ray offset
    ray.TMin = ViewDepthToRay(ray.Direction, depthInTex[pixel]) + epsilon; // start after first known hit

    uint iRayMin = rayMinTex[pixel];
    if (iRayMin != 0u) // test if valid values
        ray.TMin = max(asfloat(iRayMin), ray.TMin);
    
    uint iRayMax = rayMaxTex[pixel];
    if (iRayMax != 0u) // test if valid values
        ray.TMax = min(asfloat(iRayMax), ray.TMax);
    
    return ray;
}


// abstract:
#ifndef TEXTURE_LOD_T
#define TEXTURE_LOD_T ImplicitLodTextureSampler
#endif
TEXTURE_LOD_T computeLod(VertexData v, float3 rayDir);

// returns true if the ray sample can be commited
bool algorithm(inout float depths[NUM_SAMPLES], inout uint count, float2 barycentrics, float t, GeometryInstanceID instanceID, uint primitiveIndex, float3 rayDir)
{
#define SD_VERSION 2
#define MAX_COUNT (2 * NUM_SAMPLES)

    float rng = hash(barycentrics);
    
#if SD_VERSION == 2
    uint slot = count; // insertion slot
    if (count >= NUM_SAMPLES)
        slot = uint(rng * count); // slot in [0, count - 1]
    
    count += 1;
    if (slot >= NUM_SAMPLES) // rejected?
    {
        if (count > MAX_COUNT)
            return true; // commit
        return false; // no commit, further traverses
    }

    // accepted => do (early) depth test
    t = RayToViewDepth(rayDir, t); // convert to view depth
    if (NORMALIZE)
        t = saturate((t - gScene.camera.data.nearZ) / (gScene.camera.data.farZ - gScene.camera.data.nearZ));

    //if (rayData.depths[slot] <= t)
    //    IgnoreHit();
    for (uint i = 0; i < NUM_SAMPLES; ++i)
    {
        if (i == slot && depths[i] <= t)
            return false; // rejected due to depth test
    }

    #endif

    { // ALPHA test
        TriangleHit hit;
        hit.instanceID = instanceID;
        hit.primitiveIndex = primitiveIndex;
        hit.barycentrics = barycentrics;
        const uint materialID = gScene.getMaterialID(hit.instanceID);
        const MaterialHeader header = gScene.materials.materialData[materialID].header;

        // needs alpha testing?
        if (header.getAlphaMode() == AlphaMode::Mask)
        {
            const VertexData v = gScene.getVertexData(hit);
            if (gScene.materials.alphaTest(v, materialID, computeLod(v, rayDir)))  
                return false; // alpha test failed => ignore this triangle
        }
    }
    

    
    
#if SD_VERSION == 2
    for (uint i = 0; i < NUM_SAMPLES; ++i)
    {
        if (i == slot)
            depths[i] = t;
    }

    if (count > MAX_COUNT)
        return true; // commit => max count reached
    return false; // further traverse

    //float rng2 = hash3D(float3(attribs.barycentrics, t));
    //if (rng2 < 0.2) // small chance to keep traversal going
    //if(rayData.count < 5)
    //    IgnoreHit(); 
#endif
#if SD_VERSION == 1
    int R = int(floor(ALPHA * NUM_SAMPLES + rng));
    uint coverageMask = 0;
    
    if (R >= NUM_SAMPLES)
    {
        coverageMask = 0xffff; // maximum 32 samples
    }
    else if (R != 0)
    {
        float rng2 = hash3D(float3(attribs.barycentrics, t));
        int index = int(lerp(stratifiedIndices[R], stratifiedIndices[R + 1], rng2));
        coverageMask = stratifiedLookUpTable[index];
    }

    float maxT = 0.0;
    [unroll]
    for (uint i = 0; i < NUM_SAMPLES; ++i)
    {
        if (coverageMask & (1 << i))
            rayData.depths[i] = min(rayData.depths[i], t); // z-test enabled
        maxT = max(maxT, rayData.depths[i]);
    }

    if (t < maxT)
        IgnoreHit(); // keep looking for hits, otherwise start to terminate
#endif
}
